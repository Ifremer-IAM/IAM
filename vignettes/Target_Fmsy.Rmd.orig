---
title: "Estimation du TAC pour atteinte du Fmsy"
output:
  pdf_document:
    keep_tex: yes
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Target_Fmsy}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setpknitr, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r dep, message=FALSE, warning=FALSE}
x = Sys.time()
# Dépendances pour l'analyse des données et les représentations graphiques.
library(magrittr)
library(ggplot2)
library(dplyr)
library(IAM)
library(parallel)
```

Le modèle bio-économique IAM a été développé dans l'optique d'être utilisé pour des scénarios de gestion de quotas. Ainsi, des scénarios de Gestion par TAC peuvent être introduit à différentes échelles. Ce document traite de la gestion intra flotilles d'estimation du TAC pour lequel de $F_{msy}$ ($F$ for maximum sustainable yeald) est atteins à une certaine date..

L'ensemble de ces simulations sera réalisé avec le jeu de donnée example `Ifremer` composé de 7 flotilles et deux 3 espèces dynamiques dont une espèce à dynamique SS3.

**Attention ce document lance de nombreuses simulations et prend donc un temps long à simuler (plusieurs dizaines de minutes.**

```{r inport, eval = FALSE, include=FALSE}
load(IAM_example("IAM_SS3_1984.RData"))

IAM_input_1984 <- IAM::IAM.input(
  fileIN = IAM_example("inputFile.xlsx"),
  t_init = 1984, nbStep = 12, folderFleet = IAM_example("fleets"),
  Fq_i = list(DAR = iniFq_i), iniFq_i = list(DAR = iniFq_i),
  Fq_fmi = list(DAR = iniFq_fmi), iniFq_fmi = list(DAR = iniFq_fmi),
  FqLwt_i = list(DAR = iniFqLwt_i), iniFqLwt_i = list(DAR = iniFqLwt_i),
  FqLwt_fmi = list(DAR = iniFqLwt_fmi), iniFqLwt_fmi = list(DAR = iniFqLwt_fmi),
  FqDwt_i = list(DAR = iniFqDwt_i), iniFqDwt_i = list(DAR = iniFqDwt_i),
  FqDwt_fmi = list(DAR = iniFqDwt_fmi), iniFqDwt_fmi = list(DAR = iniFqDwt_fmi),
  Nt0s1q = list(DAR = Nt0s1q), Ni0q = list(DAR = Ni0q),
  iniNt0q = list(DAR = iniNt0q), matwt = list(DAR = mat_morphage)
)
summary(IAM_input_1984)
```


```{r falseinport}
data("IAM_input_1984")
summary(IAM_input_1984)
```

L'objet argument est laissé tel quel lors de l'utilisation de l'interface et sera édité à la main plus tard pour chaque scénario.

```{r argum, eval=FALSE}
IAM_argum_1984 <- IAM.args(IAM_input_1984)
```

Cela revient à initialiser un objet de classe `iamArgs` sans passer par l'interface avec la commande suivante :

```{r init_argum}
IAM_argum_1984 <- IAM.input2args(IAM_input_1984)
```

## Besoin d'un scénario *statu quo*

Afin de pouvoir comparer l'effet de chaque scénario, il nous faut un scénario de départ dans lequel aucune mesure de Gestion s'imposera.

Dans un premier temps il est utile de définir les dynamiques de recrutements ainsi que des éléments de paramétrage du module économique. On va pour cela éditer l'objet `IAM_argum_1984`.

```{r edit argum}
# Module SR
# Add noise to COR
IAM_argum_1984@arguments$Recruitment$COR$wnNOISEmodSR <- 5000000

# Module EcoDCF
IAM_argum_1984 <- IAM.editArgs_Eco(IAM_argum_1984, dr = 0.04, perscCalc = 1)

# Module Gestion
mfm <- with(IAM_input_1984@input$Fleet,{
  (effort1_f_m * effort2_f_m * nbv_f_m) / as.vector(effort1_f * effort2_f * nbv_f)
})
mfm[is.na(mfm)] <- 0

IAM_argum_1984 <- IAM.editArgs_Gest(IAM_argum_1984, active = FALSE,
                                    delay = 1, mfm = mfm)

# Module Scenario
IAM_argum_1984 <- IAM.editArgs_Scenar(IAM_argum_1984) # desactivate scenario

summary(IAM_argum_1984)
```


## Selection des différents TACs.

La recherche du TAC pour atteindre le $F_{msy}$ se fait en simulant plusieurs scénarios avec des TACs.

Je choisis de simuler tout mes scénarios avec des réplicats, qui est fixé ici par `N`

```{r setN}
N = 200
Fmsy <- 0.32

# Je définie également une fonction pour upd TAC
# Function for simulation under TAC
simultac <- function(x, IAM_argum_1984_noTAC, IAM_input_1984, N){

  argum <- IAM.editArgs_Gest(IAM_argum_1984_noTAC, type = "x", active = TRUE,
                             tac = c(NA, NA, rep(x, 10)) )

  sim <- replicate(N, {
  IAM::IAM.model(objArgs = argum,  objInput = IAM_input_1984)
  })

  siml <- lapply(1:N,  function(y) {
    IAM.format(sim[[y]], name = c("Fbar", "SSB", "L_et"),
               sim_name = as.character(x), n = y)
  })
  sim <- do.call(rbind, siml)

  return(sim)
}
```

Simulation du scénario SQ

```{r SQ}
IAM_argum_1984_noTAC <- IAM.editArgs_Gest(
  IAM_argum_1984, active = FALSE, control = "Nb trips", target = "TAC",
  espece = "COR", delay = 2,
  type = "x", bounds = c(1e7, -1e4), 
  tac = c(NA, NA, rep(3600, 10)))
      #   84, 85,     1986:1995

# Statu quo
SQ <- replicate(N, {
  IAM::IAM.model(objArgs = IAM_argum_1984_noTAC,  objInput = IAM_input_1984)
})

SQl <- lapply(1:N,  function(y) {
  IAM.format(SQ[[y]], name = c("Fbar", "SSB", "L_et"),
             sim_name = "SQ", n = y)
})
SQ <- do.call(rbind, SQl)
```



```{r simuls, message = FALSE}
x <- Sys.time()
# Apply TAC
TACS <- seq(3000, 3800, by = 200)

# Warning ! Code run for long time.
cl <- makeCluster(detectCores()-1)
invisible(clusterEvalQ(cl,library(IAM)))

res <-parLapply(cl, as.list(TACS), simultac,
                 IAM_argum_1984_noTAC, IAM_input_1984, N)
stopCluster(cl)

res <- do.call(rbind, c(res, list(SQ)))
print(Sys.time() - x)
```


### Représentations graphiques

On peut aisement comparer les différents scénarios avec des fonctions graphiques. Ainsi on observe que nos scénarios de TAC arrivent tout deux à la reconstruction progressive du stock "COR" par une baisse de la mortalité par pêche (Fbar).

```{r COR_bio_variables, fig.cap=paste("\\label{fig:TAC}COR variables for different TAC scenarii.",N, "runs." )}
COR <- res %>%
  filter(species == "COR") %>%
  IAM.format_quant(., probs = c(.025, .975))

COR %>%
  ggplot(aes(x = year, y = median)) +
  facet_grid(variable ~ sim_name, scales = "free_y") +
  geom_ribbon(aes(ymin = quant1, ymax = quant2), fill = "lightblue") +
  geom_line() +
  geom_line(aes(y = value), linetype = "dotted") +
  geom_vline(xintercept=1986, linetype = "dotted") +
  IAM_theme() +
  NULL

```

```{r calcProban, fig.cap=paste("\\label{fig:TACp}Fmsy Probability over", N, "runs. Target Fmsy for COR species is :", Fmsy)}
line_data <- data.frame(xintercept = c(1986, 1990), 
                        Lines = c("Scenarii start", "Target Fmsy"),
                        linetype = c("dotted", "dashed"), 
                        stringsAsFactors = FALSE)

Proba <- res %>%
  filter(species == "COR") %>%
  group_by(.data$sim_name, .data$variable, .data$year) %>%
    summarize(Pfmsy = sum(.data$value <= Fmsy) / length(unique(n)) * 100,
              .groups = "keep") %>% ungroup()

Proba %>%
  filter(variable == "Fbar") %>%
  ggplot(aes(x = year, y = Pfmsy, color = as.factor(sim_name)))+
  geom_line() +
  geom_vline(xintercept= line_data$xintercept, linetype = line_data$linetype) +
  annotate("text", line_data$xintercept, 100, hjust = -.25, 
    label = line_data$Lines) +
  scale_colour_discrete(name  ="TAC constant") +
  NULL

filter(Proba, year == 1990, variable == "Fbar")
print(Sys.time() - x) # 50 -> 3 min
beepr::beep(5)
```

## TAC jusqu'au Fmsy.

On reproduit l'analyse précédente mais en changeant la cible des scénarios. Ainsi on va ici viser un TAC jusqu'à atteinte d'un Fbar.

**Je ne comprend pas pourquoi ça marche pas...**

Je choisis de simuler tout mes scénarios avec des réplicats, qui est fixé ici par `N`


```{r multTACsim_fmsy, message = FALSE}
IAM_argum_1984_noTAC_fmsy <- IAM.editArgs_Gest(
  IAM_argum_1984, active = FALSE, control = "Nb trips", target = "TAC->Fbar",
  espece = "COR", delay = 2,
  type = "x", bounds = c(100, -100), 
  tac = c(NA, NA, rep(3600, 10)),
  fbar = c(NA, NA, rep(Fmsy, 10)))
      #   84, 85,  1991:1995

# Apply TAC
TACS <- seq(3000, 3800, by = 200)

# Warning ! Code run for long time.
cl <- makeCluster(detectCores()-1)
invisible(clusterEvalQ(cl,library(IAM)))

res <-parLapply(cl, as.list(TACS), simultac,
                IAM_argum_1984_noTAC_fmsy, IAM_input_1984, N)
stopCluster(cl)

res <- do.call(rbind, c(res, list(SQ)))
```


### Représentations graphiques

On peut aisement comparer les différents scénarios avec des fonctions graphiques. Ainsi on observe que nos scénarios de TAC arrivent tout deux à la reconstruction progressive du stock "COR" par une baisse de la mortalité par pêche (Fbar).

```{r COR_bio_variables_fmsy, fig.cap=paste("\\label{fig:fbar}COR variables for different TAC scenarii.",N, "runs." )}
COR <- res %>%
  filter(species == "COR") %>%
  IAM.format_quant(., probs = c(.025, .975))

COR %>%
  ggplot(aes(x = year, y = median)) +
  facet_grid(variable ~ sim_name, scales = "free_y") +
  geom_ribbon(aes(ymin = quant1, ymax = quant2), fill = "lightblue") +
  geom_line() + geom_point(size = .5) +
  geom_line(aes(y = value), linetype = "dotted") +
  geom_vline(xintercept=1986, linetype = "dotted") +
  IAM_theme() +
  NULL

```

### Calcul de la probabilité d'atteindre le $F_{msy}$

On peut calculer la probabilité d'atteindre le $F_{msy}$ comme le pourcentage de simulation ayant un $F_{bar} < F_{msy}$.

```{r calcProban_fmsy, fig.cap=paste("\\label{fig:fbarp}Fmsy Probability over", N, "runs. Target Fmsy for COR species is :", Fmsy)}
line_data <- data.frame(xintercept = c(1986, 1990), 
                        Lines = c("Scenarii start", "Target Fmsy"),
                        linetype = c("dotted", "dashed"), 
                        stringsAsFactors = FALSE)

Proba <- res %>%
  filter(species == "COR") %>%
  group_by(.data$sim_name, .data$variable, .data$year) %>%
    summarize(Pfmsy = sum(.data$value <= Fmsy) / length(unique(n)) * 100,
              .groups = "keep") %>% ungroup()

Proba %>%
  filter(variable == "Fbar") %>%
  ggplot(aes(x = year, y = Pfmsy, color = as.factor(sim_name)))+
  geom_line() +
  geom_vline(xintercept= line_data$xintercept, linetype = line_data$linetype) +
  annotate("text", line_data$xintercept, 100, hjust = -.25, 
    label = line_data$Lines) +
  scale_colour_discrete(name  ="TAC constant") +
  NULL

filter(Proba, year == 1990, variable == "Fbar")
print(Sys.time() - x) # 50 -> 3 min
beepr::beep(5)
```

